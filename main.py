"""
Лука наблюдает за кузнечиками
Ограничение по времени: 1 секунда

Любимое занятие Луки — наблюдать за кузнечиками.
Сегодня утром, прогуливаясь по парку, он обнаружил кузнечика, который прыгал по окружности длиной n метров.
Лука заметил, что за один прыжок кузнечик может переместиться по часовой стрелке на k или k+1 метров от своей текущей
позиции на окружности.
Мальчику стало интересно, какое минимальное количество прыжков потребуется кузнечику, чтобы,
начав прыгать из некоторой точки окружности, снова оказаться в ней.

Формат входных данных
Первая строка содержит одно целое число n (1≤n≤10⁶) — длина окружности в метрах.
Вторая строка содержит одно целое число k (1≤k≤10⁹) — характеристика длины прыжка кузнечика в метрах.
Гарантируется, что 1≤n⋅k≤10⁹.

Формат выходных данных
Выведите одно целое число — минимальное количество прыжков, которое придётся сделать кузнечику, чтобы, начав прыгать
из некоторой точки окружности, снова оказаться в ней.

Система оценки
Решения, правильно работающие только для случаев, когда n не превосходит 100, будут оцениваться в 60 баллов.

Пояснение
Рассмотрим первый пример из условия. Один из вариантов действий кузнечика таков:

Выполнить прыжок длины 3,
Выполнить прыжок длины 4,
Выполнить прыжок длины 3.
Таким образом, суммарно кузнечик преодолеет 3+4+3=10 метров, то есть вернётся в исходную точку.
Во втором примере из условия кузнечику достаточно выполнить пять прыжков длины 2.
В третьем примере из условия можно выполнить один прыжок длины 8 и два прыжка длины 7.
Таким образом, суммарно кузнечик преодолеет 8+7+7=22 метра, то есть обойдёт окружность дважды и вернётся в исходную точку.

Ввод
10
3
Вывод
3
Ввод
10
1
Вывод
5
Ввод
11
7
Вывод
3

"""


def validate_input(msg: str, sup: int = 10_000_000_000) -> int:
    """Validates input value and converts it into integer"""
    val = 0
    while sup < val <= 0:
        try:
            val = int(input(msg))
        except ValueError:
            continue
    return val


def calculate_leaps(circle_length: int, leap_length: int) -> int:
    """Compute a minimum count of leaps to achieve the same point of the circle """
    short_leaps_count = circle_length // leap_length  # целое число прыжков в круге
    short_reminder = circle_length % leap_length  # остаток недопрыгнутого

    long_leap_length = leap_length + 1
    long_leaps_count = circle_length // long_leap_length  # целое число длинных прыжков в круге
    long_reminder = circle_length % long_leap_length  # остаток недопрыгнутого при длинных прыжках

    # Возможные случаи:
    #
    # 1. leaps_count == 0
    #   Кузнечик прыгает дальше, чем длина круга, тогда reminder - насколько он дальше прыгает
    #
    # 2. leaps_count > 0, reminder == 0: НО!
    #   Длина круга делится нацело на длину прыжка
    #
    #       2.1. long_leaps_count > 0, long_reminder == 0 Если каждый прыжок увеличить +1
    #           return long_leaps_count
    #
    #       2.2  long_leaps_count > 0, 0 < long_reminder <= leaps_count

    #
    # 3. leaps_count > 0, 0 < reminder <= leaps_count:
    #   Можем добрать недостающее, добавляя +1м к некоторым прыжкам
    #
    # 4. leaps_count > 0, reminder > leaps_count:
    #   надо прыгать несколько кругов
    #       4.1 Проверяем для circle_length*2 и leap_length - рекурсивно вызываем эту же функцию
    # TODO: Выяснить, могут ли  быть другие случаи?

    # if leaps_count > 0 and 0 <= reminder <= leaps_count:  # 2, 3 случай
    #     return leaps_count
    # TODO: Нужна проверка?


if __name__ == '__main__':
    n = validate_input('Введите длину окружности')
    k = validate_input('Введите длину прыжка')
    leaps_count = calculate_leaps(n, k)

    print(leaps_count)


